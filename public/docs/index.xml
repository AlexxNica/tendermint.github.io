<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docs on Tendermint</title>
    <link>http://tendermint.com/docs/</link>
    <description>Recent content in Docs on Tendermint</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 03 Mar 2016 11:59:27 +0800</lastBuildDate>
    <atom:link href="http://tendermint.com/docs/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Source Code</title>
      <link>http://tendermint.com/docs/code/</link>
      <pubDate>Thu, 03 Mar 2016 11:59:27 +0800</pubDate>
      
      <guid>http://tendermint.com/docs/code/</guid>
      <description>&lt;section id=&#34;section-top&#34;&gt;
  &lt;div class=&#34;section-container&#34;&gt;
    &lt;h1&gt;&lt;i class=&#34;fa fa-code&#34;&gt;&lt;/i&gt; Source Code&lt;/h1&gt;
    &lt;p&gt;Develop on Tendermint&amp;rsquo;s open source platform. Start learning with &lt;a href=&#34;http://tendermint.com/guide&#34;&gt;the guide&lt;/a&gt;.&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/section&gt;

&lt;section class=&#34;section-default&#34;&gt;
  &lt;div class=&#34;section-container&#34;&gt;
    &lt;div class=&#34;section-content&#34;&gt;
      &lt;div class=&#34;panels&#34;&gt;
        &lt;div class=&#34;panel panel-external&#34;&gt;
          &lt;div class=&#34;panel-container&#34;&gt;
            &lt;div class=&#34;panel-header&#34;&gt;
              &lt;h3&gt;&lt;a href=&#34;https://github.com/tendermint/tendermint/&#34; class=&#34;block&#34;&gt;
                &lt;i class=&#34;fa fa-github&#34;&gt;&lt;/i&gt; GitHub&lt;/a&gt;&lt;/h3&gt;
            &lt;/div&gt;
            &lt;div class=&#34;panel-body&#34;&gt;
              &lt;ul&gt;
                &lt;li&gt;&lt;a href=&#34;http://github.com/tendermint/tendermint/wiki&#34;&gt;
                  &lt;h4&gt;Tendermint Spec&lt;/h4&gt;
                  &lt;p&gt;Get an overview of Tendermint&amp;rsquo;s structure, algorithms, and roadmap.&lt;/p&gt;
                &lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&#34;https://github.com/tendermint/tendermint&#34;&gt;
                  &lt;h4&gt;Tendermint Core&lt;/h4&gt;
                  &lt;p&gt;Tendermint Core&lt;/p&gt;
                &lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&#34;https://github.com/tendermint/tmsp&#34;&gt;
                  &lt;h4&gt;TMSP&lt;/h4&gt;
                  &lt;p&gt;Tendermint socket protocol for blockchain applications&lt;/p&gt;
                &lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&#34;https://github.com/tendermint/mintnet&#34;&gt;
                  &lt;h4&gt;Mintnet&lt;/h4&gt;
                  &lt;p&gt;Developer tool for deploying a Tendermint testnet&lt;/p&gt;
                &lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&#34;https://github.com/tendermint/go-p2p&#34;&gt;
                  &lt;h4&gt;Go-P2P&lt;/h4&gt;
                  &lt;p&gt;Extensible P2P networking stack&lt;/p&gt;
                &lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&#34;https://github.com/tendermint/go-merkle&#34;&gt;
                  &lt;h4&gt;Go-Merkle&lt;/h4&gt;
                  &lt;p&gt;Merkle hash trees for blocks and application state&lt;/p&gt;
                &lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&#34;https://github.com/tendermint/go-wire&#34;&gt;
                  &lt;h4&gt;Go-Wire&lt;/h4&gt;
                  &lt;p&gt;Binary and JSON encoding/decoding&lt;/p&gt;
                &lt;/a&gt;&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/div&gt;&lt;!--panel-body--&gt;
          &lt;/div&gt;&lt;!--panel-container--&gt;
        &lt;/div&gt;&lt;!--panel--&gt;
      &lt;/div&gt;&lt;!--panels--&gt;
    &lt;/div&gt;&lt;!--section-content--&gt;
  &lt;/div&gt;&lt;!--section-container--&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://tendermint.com/docs/faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/docs/faq/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>http://tendermint.com/docs/guides/app-architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/docs/guides/app-architecture/</guid>
      <description>

&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;

&lt;p&gt;A blockchain application is more than the consensus engine and the transaction logic (eg. smart contracts, business logic) as implemented in the TMSP app.  There are also (mobile, web, desktop) clients that will need to connect and make use of the app.  We will assume for now that you have a well designed transactions and database model, but maybe this will be the topic of another article.  This article is more interested in various ways of setting up the &amp;ldquo;plumbing&amp;rdquo; and connecting these pieces, and demonstrating some evolving best practices.&lt;/p&gt;

&lt;h1 id=&#34;security&#34;&gt;Security&lt;/h1&gt;

&lt;p&gt;A very important aspect when constructing a blockchain is security.  The consensus model can be DoSed (no consensus possible) by corrupting &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; of the validators and exploited (writing arbitrary blocks) by corrupting &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; of the validators. So, while the security is not that of the &amp;ldquo;weakest link&amp;rdquo;, you should take care that the &amp;ldquo;average link&amp;rdquo; is sufficiently hardened.&lt;/p&gt;

&lt;p&gt;One big attack surface on the validators is the communication between the TMSP app and the tendermint core.  This should be highly protected. Ideally, the app and the core are running on the same machine, so no external agent can target the communication channel.  You can use unix sockets (with permissions preventing access from other users), or even compile the two apps into one binary if the TMSP app is also writen in go (@ebuchman says this is possible). If you are unable to do that due to language support, then the TMSP app should bind a TCP connection to localhost (127.0.0.1), which is less efficient and secure, but still not reachable from outside.  If you must run the TMSP app and tendermint core on separate machines, make sure you have a secure communication channel (ssh tunnel?)&lt;/p&gt;

&lt;p&gt;Now assuming, you have linked together your app and the core securely, you must also make sure no one can get on the machine it is hosted on.  At this point it is basic network security. Run on a secure operating system (SELinux?). Limit who has access to the machine (user accounts, but also where the physical machine is hosted).  Turn off all services except for ssh, which should only be accessible by some well-guarded public/private key pairs (no password). And maybe even firewall off access to the ports used by the validators, so only known validators can connect.&lt;/p&gt;

&lt;p&gt;There was also a suggestion on slack from @jhon about compiling everything together with a unikernel for more security, such as &lt;a href=&#34;https://mirage.io&#34;&gt;Mirage&lt;/a&gt; or &lt;a href=&#34;https://github.com/emc-advanced-dev/unik&#34;&gt;UNIK&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;connecting-your-client-to-the-blockchain&#34;&gt;Connecting your client to the blockchain&lt;/h1&gt;

&lt;h2 id=&#34;tendermint-core-rpc&#34;&gt;Tendermint Core RPC&lt;/h2&gt;

&lt;p&gt;I believe this was the original design from @ebuchman.  The concept is that the TMSP app is completely hidden from the outside world and only communicated through a tested and secured &lt;a href=&#34;../RPC&#34;&gt;interface exposed by the tendermint core&lt;/a&gt;.  This interface exposes a lot of data on the block header and consensus process, which is quite useful for externally verifying the system.  It also includes 3(!) methods to broadcast a transaction (propose it for the blockchain, and possibly await a response).  And one method to query app-specific data from the TMSP application.&lt;/p&gt;

&lt;p&gt;Pros:
* Server code already written
* Access to block headers to validate merkle proofs (nice for light clients)
* Basic read/write functionality is supported&lt;/p&gt;

&lt;p&gt;Cons:
* Limited interface to app.  All queries must be serialized into []byte (less expressive than JSON over HTTP) and there is no way to push data from TMSP app to the client (eg. notify me if account X receives a transaction)&lt;/p&gt;

&lt;h2 id=&#34;custom-tmsp-server&#34;&gt;Custom TMSP server&lt;/h2&gt;

&lt;p&gt;This was proposed by @wolfposd on slack and demonstrated by &lt;a href=&#34;https://github.com/wolfposd/TMChat&#34;&gt;TMChat&lt;/a&gt;, a sample app. The concept is to write a custom server for your app (with typical REST API/websockets/etc for easy use by a mobile app). This custom server is in the same binary as the TMSP app and data store, so can easily react to complex events there that involve understanding the data format (send a message if my balance drops below 500). All &amp;ldquo;writes&amp;rdquo; sent to this server are proxied via websocket/JSON-RPC to tendermint core.  When they come back as append_tx over TMSP, they will be written to the data store. For &amp;ldquo;reads&amp;rdquo;, we can do any queries we wish that are supported by our architecture, using any web technology that is useful. The general architecture is shown in the following diagram:&lt;/p&gt;

&lt;p&gt;[[&lt;a href=&#34;https://github.com/wolfposd/tutorials/blob/master/images/tendermint/TMApplicationExample.png|alt=applicationarchitecture]&#34;&gt;https://github.com/wolfposd/tutorials/blob/master/images/tendermint/TMApplicationExample.png|alt=applicationarchitecture]&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Pros:
* Separates application logic from blockchain logic
* Allows much richer, more flexible client-facing API
* Allows pub-sub, watching certain fields, etc.&lt;/p&gt;

&lt;p&gt;Cons:
* Access to TMSP app can be dangerous (be VERY careful not to write unless it comes from the validator node)
* No direct access to the blockchain headers to verify tx
* You must write your own API (but maybe that&amp;rsquo;s a pro&amp;hellip;)&lt;/p&gt;

&lt;h2 id=&#34;hybrid-solutions&#34;&gt;Hybrid solutions&lt;/h2&gt;

&lt;p&gt;Likely the least secure but most versatile.  The client can access both the tendermint node for all blockchain info, as well as a custom app server, for complex queries and pub-sub on the tmsp app.&lt;/p&gt;

&lt;p&gt;Pros:
* All from both above solutions&lt;/p&gt;

&lt;p&gt;Cons:
* Even more complexity
* Even more attack vectors (less security)&lt;/p&gt;

&lt;h1 id=&#34;scalability&#34;&gt;Scalability&lt;/h1&gt;

&lt;p&gt;Read replica using non-validating nodes?  They could forward transactions to the validators (fewer connections, more security), and locally allow all queries in any of the above configurations. Thus, while transaction-processing speed is limited by the speed of the tmsp app and the number of validators, one should be able to scale our read performance to quite an extent (until the replication process drains too many resources from the validator nodes).&lt;/p&gt;

&lt;h1 id=&#34;example-code&#34;&gt;Example Code&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/wolfposd/TMChat&#34;&gt;TMChat&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TODO: more!&lt;/p&gt;

&lt;h1 id=&#34;contributions&#34;&gt;Contributions&lt;/h1&gt;

&lt;p&gt;Many thanks to Ethan Frey for writing this page.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://tendermint.com/docs/guides/app-dev/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/docs/guides/app-dev/</guid>
      <description>

&lt;h1 id=&#34;tmsp-design&#34;&gt;TMSP Design&lt;/h1&gt;

&lt;p&gt;The purpose of TMSP is to provide a clean interface between state transition machines on one computer and the mechanics of their replication across multiple computers. The former we call &amp;lsquo;application logic&amp;rsquo; and the latter the &amp;lsquo;consensus engine&amp;rsquo;. Application logic validates transactions and optionally executes transactions against some persistent state. A consensus engine ensures all transactions are replicated in the same order on every machine. We call each machine in a consensus engine a &amp;lsquo;validator&amp;rsquo;, and each validator runs the same transactions through the same application logic. In particular, we are interested in blockchain-style consensus engines, where transactions are committed in hash-linked blocks.&lt;/p&gt;

&lt;p&gt;The TMSP design has a few distinct components:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;message protocol

&lt;ul&gt;
&lt;li&gt;pairs of request and response messages&lt;/li&gt;
&lt;li&gt;consensus makes requests, application responds&lt;/li&gt;
&lt;li&gt;defined using protobuf&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;server/client

&lt;ul&gt;
&lt;li&gt;consensus engine runs the client&lt;/li&gt;
&lt;li&gt;application runs the server&lt;/li&gt;
&lt;li&gt;two implementations:

&lt;ul&gt;
&lt;li&gt;async raw bytes&lt;/li&gt;
&lt;li&gt;grpc&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;blockchain protocol

&lt;ul&gt;
&lt;li&gt;tmsp is connection oriented&lt;/li&gt;
&lt;li&gt;Tendermint Core maintains three connections:

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mempool-connection&#34;&gt;mempool connection&lt;/a&gt;: for checking if transactions should be relayed before they are committed. only uses &lt;code&gt;CheckTx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#consensus-connection&#34;&gt;consensus connection&lt;/a&gt;: for executing transactions that have been committed. Message sequence is, for every block, &lt;code&gt;BeginBlock, [AppendTx, ...], EndBlock, Commit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#query-connection&#34;&gt;query connection&lt;/a&gt;: for querying the application state.  only uses Query and Info&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/ebuchman/thesis/raw/master/figures/diagrams/tmsp.png&#34; width=&#34;600&#34;&gt;&lt;/p&gt;

&lt;p&gt;The mempool and consensus logic act as clients, and each maintains an open TMSP connection with the application, which hosts a TMSP server. Shown are the request and response types sent on each connection.&lt;/p&gt;

&lt;h1 id=&#34;message-protocol&#34;&gt;Message Protocol&lt;/h1&gt;

&lt;p&gt;The message protocol consists of pairs of requests and responses. Some messages have no fields, while others may include byte-arrays, strings, or integers. See the &lt;code&gt;message Request&lt;/code&gt; and &lt;code&gt;message Response&lt;/code&gt; definitions in &lt;a href=&#34;https://github.com/tendermint/tmsp/blob/master/types/types.proto&#34;&gt;the protobuf definition file&lt;/a&gt;, and the &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34;&gt;protobuf documentation&lt;/a&gt; for more details.&lt;/p&gt;

&lt;p&gt;For each request, a server should respond with the corresponding response, where order of requests is preserved in the order of responses.&lt;/p&gt;

&lt;h1 id=&#34;server&#34;&gt;Server&lt;/h1&gt;

&lt;p&gt;To use TMSP in your programming language of choice, there must be a TMSP server in that language.
Tendermint supports two kinds of implementation of the server:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Asynchronous, raw socket server&lt;/li&gt;
&lt;li&gt;GRPC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Both can be tested using the &lt;code&gt;tmsp-cli&lt;/code&gt; by setting the &lt;code&gt;--tmsp&lt;/code&gt; flag appropriately (ie. to &lt;code&gt;socket&lt;/code&gt; or &lt;code&gt;grpc&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;See examples, in various stages of maintenance, in &lt;a href=&#34;https://github.com/tendermint/tmsp/tree/master/server&#34;&gt;go&lt;/a&gt;, &lt;a href=&#34;https://github.com/tendermint/js-tmsp&#34;&gt;javascript&lt;/a&gt;, &lt;a href=&#34;https://github.com/tendermint/tmsp/tree/master/example/python3/tmsp&#34;&gt;python&lt;/a&gt;, &lt;a href=&#34;https://github.com/mdyring/cpp-tmsp&#34;&gt;c++&lt;/a&gt;, and &lt;a href=&#34;https://github.com/jTMSP/jTMSP&#34;&gt;java&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;grpc&#34;&gt;GRPC&lt;/h2&gt;

&lt;p&gt;If GRPC is available in your language, this is the easiest approach,
though it will have significant performance overhead.&lt;/p&gt;

&lt;p&gt;To get started with GRPC, copy in the &lt;a href=&#34;https://github.com/tendermint/tmsp/blob/master/types/types.proto&#34;&gt;protobuf file&lt;/a&gt; and compile it using the GRPC plugin for your language.
For instance, for golang, the command is &lt;code&gt;protoc --go_out=plugins=grpc:. types.proto&lt;/code&gt;. See the &lt;a href=&#34;http://www.grpc.io/docs/&#34;&gt;grpc documentation for more details&lt;/a&gt;. &lt;code&gt;protoc&lt;/code&gt; will autogenerate all the necessary code for TMSP client and server in your language, including whatever interface your application must satisfy to be used by the TMSP server for handling requests.&lt;/p&gt;

&lt;h2 id=&#34;async-raw&#34;&gt;Async Raw&lt;/h2&gt;

&lt;p&gt;If GRPC is not available in your language, or you require higher performance, or otherwise enjoy programming, you may implement your own TMSP server.
The first step is still to auto-generate the relevant data types and codec in your language using &lt;code&gt;protoc&lt;/code&gt;.
Messages coming over the socket are Protobuf3 encoded, but additionally length-prefixed to facilitate use as a streaming protocol. Protobuf3 doesn&amp;rsquo;t have an official length-prefix standard, so we use our own. The first byte in the prefix represents the length of the Big Endian encoded length. The remaining bytes in the prefix are the Big Endian encoded length.&lt;/p&gt;

&lt;p&gt;For example, if the Protobuf3 encoded TMSP message is 0xDEADBEEF (4 bytes), the length-prefixed message is 0x0104DEADBEEF. If the Protobuf3 encoded TMSP message is 65535 bytes long, the length-prefixed message would be like 0x02FFFF&amp;hellip;.&lt;/p&gt;

&lt;p&gt;Note this prefixing does not apply for grpc.&lt;/p&gt;

&lt;p&gt;A TMSP server must also be able to support multiple connections, as Tendermint uses three connections.&lt;/p&gt;

&lt;h1 id=&#34;client&#34;&gt;Client&lt;/h1&gt;

&lt;p&gt;There are currently two use-cases for a TMSP client.
One is a testing tool, as in the &lt;code&gt;tmsp-cli&lt;/code&gt;, which allows TMSP requests to be sent via command line.
The other is a consensus engine, such as Tendermint Core, which makes requests to the application every time a new transaction is received or a block is committed.&lt;/p&gt;

&lt;p&gt;It is unlikely that you will need to implement a client. For details of our client, see &lt;a href=&#34;https://github.com/tendermint/tmsp/tree/master/client&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;blockchain-protocol&#34;&gt;Blockchain Protocol&lt;/h1&gt;

&lt;p&gt;In TMSP, a transaction is simply an arbitrary length byte-array.
It is the application&amp;rsquo;s responsibility to define the transaction codec as they please,
and to use it for both CheckTx and AppendTx.&lt;/p&gt;

&lt;p&gt;Note that there are two distinct means for running transactions, corresponding to stages of &amp;lsquo;awareness&amp;rsquo;
of the transaction in the network. The first stage is when a transaction is received by a validator from a client into the so-called mempool or transaction pool - this is where we use CheckTx. The second is when the transaction is successfully committed on more than &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; of validators - where we use AppendTx. In the former case, it may not be necessary to run all the state transitions associated with the transaction, as the transaction may not ultimately be committed until some much later time, when the result of its execution will be different.
For instance, an Ethereum TMSP app would check signatures and amounts in CheckTx, but would not actually execute any contract code until the AppendTx, so as to avoid executing state transitions that have not been finalized.&lt;/p&gt;

&lt;p&gt;To formalize the distinction further, two explicit TMSP connections are made between Tendermint Core and the application: the mempool connection and the consensus connection. We also make a third connection, the query connection, to query the local state of the app.&lt;/p&gt;

&lt;h2 id=&#34;mempool-connection&#34;&gt;Mempool Connection&lt;/h2&gt;

&lt;p&gt;The mempool connection is used &lt;em&gt;only&lt;/em&gt; for CheckTx requests.
Transactions are run using CheckTx in the same order they were received by the validator.
If the CheckTx returns &lt;code&gt;OK&lt;/code&gt;, the transaction is kept in memory and relayed to other peers in the same order it was received. Otherwise, it is discarded.&lt;/p&gt;

&lt;p&gt;CheckTx requests run concurrently with block processing;
so they should run against a copy of the main application state which is reset after every block.
This copy is necessary to track transitions made by a sequence of CheckTx requests before they are included in a block. When a block is committed, the application must ensure to reset the mempool state to the latest committed state. Tendermint Core will then filter through all transactions in the mempool, removing any that were included in the block, and re-run the rest using CheckTx against the post-Commit mempool state.&lt;/p&gt;

&lt;h2 id=&#34;consensus-connection&#34;&gt;Consensus Connection&lt;/h2&gt;

&lt;p&gt;The consensus connection is used only when a new block is committed, and communicates all information from the block in a series of requests:  &lt;code&gt;BeginBlock, [AppendTx, ...], EndBlock, Commit&lt;/code&gt;.
That is, when a block is committed in the consensus, we send a list of AppendTx requests (one for each transaction) sandwiched by BeginBlock and EndBlock requests, and followed by a Commit.&lt;/p&gt;

&lt;h3 id=&#34;appendtx&#34;&gt;AppendTx&lt;/h3&gt;

&lt;p&gt;AppendTx is the workhorse of the blockchain. Tendermint sends the AppendTx requests asynchronously but in order,
and relies on the underlying socket protocol (ie. TCP) to ensure they are received by the app in order. They have already been ordered in the global consensus by the Tendermint protocol.&lt;/p&gt;

&lt;p&gt;AppendTx returns a tmsp.Result, which includes a Code, Data, and Log. The code may be non-zero (non-OK), meaning the corresponding transaction should have been rejected by the mempool,
but may have been included in a block by a Byzantine proposer.&lt;/p&gt;

&lt;p&gt;The block header will be updated (TODO) to include some commitment to the results of AppendTx, be it a bitarray of non-OK transactions, or a merkle root of the data returned by the AppendTx requests, or both.&lt;/p&gt;

&lt;h3 id=&#34;commit&#34;&gt;Commit&lt;/h3&gt;

&lt;p&gt;Once all processing of the block is complete, Tendermint sends the Commit request and blocks waiting
for a response. While the mempool may run concurrently with block processing (the BeginBlock, AppendTxs, and EndBlock), it is locked for the Commit request so that its state can be safely reset during Commit. This means the app &lt;em&gt;MUST NOT&lt;/em&gt; do any blocking communication with the mempool (ie. broadcast_tx) during Commit, or there will be deadlock. Note also that all remaining transactions in the mempool are replayed on the mempool connection (CheckTx) following a commit.&lt;/p&gt;

&lt;p&gt;The Commit response includes a byte array, which is the deterministic state root of the application. It is included in the header of the next block. It can be used to provide easily verified Merkle-proofs of the state of the application.&lt;/p&gt;

&lt;p&gt;It is expected that the app will persist state to disk on Commit. The option to have all transactions replayed from some previous block is the job of the &lt;a href=&#34;#handshake&#34;&gt;Handshake&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;beginblock&#34;&gt;BeginBlock&lt;/h3&gt;

&lt;p&gt;The BeginBlock request can be used to run some code at the beginning of every block. It also allows Tendermint to send the current block hash and header to the application, before it sends any of the transactions.&lt;/p&gt;

&lt;p&gt;The app should remember the latest height and header (ie. from which it has run a successful Commit) so that it can tell Tendermint where to pick up from when it restarts. See &lt;a href=&#34;#handshake&#34;&gt;Handshake&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;endblock&#34;&gt;EndBlock&lt;/h3&gt;

&lt;p&gt;The EndBlock request can be used to run some code at the end of every block. Additionally, the response may contain a list of validators, which can be used to update the validator set. To add a new validator or update an existing one, simply include them in the list returned in the EndBlock response. To remove one, include it in the list with a &lt;code&gt;power&lt;/code&gt; equal to &lt;code&gt;0&lt;/code&gt;. Tendermint core will take care of updating the validator set (TODO).&lt;/p&gt;

&lt;h2 id=&#34;query-connection&#34;&gt;Query Connection&lt;/h2&gt;

&lt;p&gt;This connection is used to query the application without engaging consensus. It&amp;rsquo;s exposed over the tendermint core rpc, so clients can query the app without exposing a server on the app itself, but they must serialize each query as a single byte array. Additionally, certain &amp;ldquo;standardized&amp;rdquo; queries may be used to inform local decisions, for instance about which peers to connect to.&lt;/p&gt;

&lt;p&gt;Tendermint Core currently uses the Query connection to filter peers upon connecting, according to IP address or public key. For instance, returning non-OK TMSP response to either of the following queries will cause Tendermint to not connect to the corresponding peer:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;p2p/filter/addr/&amp;lt;addr&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;addr&amp;gt;&lt;/code&gt; is an IP address.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p2p/filter/pubkey/&amp;lt;pubkey&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;pubkey&amp;gt;&lt;/code&gt; is the hex-encoded ED25519 key of the node (not it&amp;rsquo;s validator key)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note: these query formats are subject to change!&lt;/p&gt;

&lt;h2 id=&#34;handshake&#34;&gt;Handshake&lt;/h2&gt;

&lt;p&gt;The tmsp handshake and related improvements are &lt;a href=&#34;https://github.com/tendermint/tendermint/issues/300&#34;&gt;upcoming in v0.8.0&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://tendermint.com/docs/guides/home/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/docs/guides/home/</guid>
      <description>

&lt;h1 id=&#34;guides&#34;&gt;Guides&lt;/h1&gt;

&lt;p&gt;Welcome to the Developer Guides!&lt;/p&gt;

&lt;p&gt;For a lighter introduction, see the &lt;a href=&#34;intro&#34;&gt;introduction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Get started building your TMSP application or server by reading the &lt;a href=&#34;docs/guides/app-dev.md&#34;&gt;application developers guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To learn about integrting with clients, see the &lt;a href=&#34;docs/guides/app-architecture.md&#34;&gt;application architecture guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;See [example applications]() for motivation and inspiration!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://tendermint.com/docs/home/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/docs/home/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;tendermint-internals&#34;&gt;Tendermint Internals&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;tendermint-commands&#34;&gt;Tendermint Commands&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;guides&#34;&gt;Guides&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;roadmap&#34;&gt;Roadmap&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;faq&#34;&gt;FAQ&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://tendermint.com/docs/roadmap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/docs/roadmap/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>http://tendermint.com/docs/tendermint-internals/home/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/docs/tendermint-internals/home/</guid>
      <description>&lt;p&gt;Everything from the wiki&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>