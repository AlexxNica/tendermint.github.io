[
  {
    "title": "Tendermint: from Then to Now",
    "slug": "tendermint-from-then-to-now",
    "date": 1474041600000,
    "body": "<h2>Tendermint: from Then to Now</h2>\n<p>Some of you have asked about the history of <a href=\"http://tendermint.com/\">Tendermint</a>, so here it is. Back in the day, we had some serious concerns about Bitcoin as a global currency, mainly because it is incredibly <a href=\"http://motherboard.vice.com/read/bitcoin-could-consume-as-much-electricity-as-denmark-by-2020\">energy intensive</a>. So we started Tendermint to develop a more environmentally friendly cryptocurrency.</p>\n<p>But what started as a simple cryptocurrency based on an adaptation of a <a href=\"http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf\">1980’s consensus algorithm called DLS</a> eventually evolved into what it is today: a general purpose Byzantine fault tolerant (BFT) consensus algorithm for running replicated state machines over the internet in possibly adversarial conditions.</p>\n<p>Replicated state machines are a staple of modern Internet technology. They permit a consistent and fault-tolerant view of some set of data. Popular open-source implementations of replicated state machines include <a href=\"http://bookkeeper.apache.org/\">Apache ZooKeeper</a>, <a href=\"https://coreos.com/etcd/\">CoreOS’ etcd</a>, and <a href=\"https://www.consul.io/\">Hashicorp’s Consul</a>.</p>\n<p>In each of these, the state machine is a simple key-value store, and the underlying consensus algorithm is either Paxos or <a href=\"https://raft.github.io/\">Raft</a>. Neither of these algorithms tolerate even a single malicious node in the system. You can see an animation of the Paxos algorithm <a href=\"http://harry.me/blog/2014/12/27/neat-algorithms-paxos/\">here</a>.</p>\n<p>In contrast, Tendermint lets you build arbitrary state machines in any programming language, whether that is a key-value store in Go, a voting system in C++, or a cryptocurrency in OCaml. In each case, the application implements a simple interface, and Tendermint handles the rest, including connecting to peers, syncing the latest state, gossipping transactions, and maintaining a consistent log of transactions.</p>\n<h2>Who is using Tendermint?</h2>\n<p>It’s been an exciting journey, and over the past few months people have been putting Tendermint to work in several applications.</p>\n<p>Probably the most complicated implementation of Tendermint so far is by Eris Industries. Eris is using Tendermint to power its <a href=\"https://erisindustries.com/components/erisdb/\">eris:db</a> blockchain client. Eris:db includes a fully compatible Ethereum virtual machine and other features that make it a full-fledged blockchain.</p>\n<p>But there are other implementations. <a href=\"http://www.cloudsoft.io/\">CloudSoft</a> published a <a href=\"http://www.cloudsoft.io/tendermint-and-clocker/\">deployment strategy</a> for Apache Brooklyn that uses Tendermint and Clocker. Martin Dyring wrote an <a href=\"https://github.com/mdyring/cpp-tmsp\">implementation of Tendermint TMSP in C++</a>, and wolfposd wrote a <a href=\"https://github.com/wolfposd/TMChat\">chatroom app in Java</a> that uses Tendermint to broadcast messages from one user to another. Yes, that’s right, a chatroom.</p>\n<p>While it might sound crazy to run a chat application on a blockchain, this is simply an example of the flexibility of Tendermint. This sort of implementation might even come in handy in instances where you have several actors who are malicious and maintaining the total order of the system matters, for instance, in p2p gaming.</p>\n<p>Other companies building on Tendermint include <a href=\"https://blockfreight.com/\">Blockfreight</a>, <a href=\"http://www.vidroll.com/\">Vidroll</a>, and <a href=\"https://stratumn.com/\">Stratumn</a> to name a few. Of course, we use Tendermint too. Our first product built on Tendermint is <a href=\"http://cosmos.network/\">Cosmos, the internet of blockchains</a>.</p>\n<h2>What’s new?</h2>\n<p>In August 2016, we released Tendermint v0.7.0, the first stable release of our middleware. It featured a weakly-synchronous BFT consensus algorithm, which can process thousands of transactions per second with latencies on the order of a second and cluster sizes ranging from 4 to 64 nodes.</p>\n<p>Recently we released <a href=\"https://github.com/tendermint/tendermint\">Tendermint v0.7.1</a>, which includes a variety of fixes, as well as the ability for applications to determine what peers Tendermint can connect to and filtering either by IP address, or by public key.</p>\n<p>In the next major release, Tendermint v0.8.0, which should be in October, we plan to introduce a handshake between Tendermint and whatever application is using it, ensuring the two stay synced even after crashes and restarts.</p>\n<p>Additionally, we’ll include some important fixes to the BFT consensus module. While testing Tendermint in adversarial conditions, we discovered a Byzantine node could potentially halt the system in some circumstances—this fix will prevent that from happening.</p>\n<p>This is critical because even though the Tendermint consensus algorithm guarantees your blockchain won’t fork, all of the subcomponents need to work perfectly to ensure liveness.</p>\n<p>Stay tuned for more updates. We are continuing to test Tendermint extensively in a push to provide a production ready offering in early 2017. And, if you are using Tendermint in a project, <a href=\"https://docs.google.com/a/tendermint.com/forms/d/e/1FAIpQLSclH87WiZrer8aUzO5oNWoSCqcbn4mwQ3sDJJX44E9rhdVJFw/viewform?c=0&amp;w=1\">let us know</a>! We want to hear how you’re using it and what your feedback is.</p>\n",
    "description": "The history of Tendermint, and information on the latest release and more",
    "dateFriendly": "September 17, 2016"
  },
  {
    "title": "On TheDAO and Proof-of-Stake Governance",
    "slug": "on-thedao-and-proof-of-stake-governance",
    "author": "Jae Kwon",
    "date": 1466438400000,
    "body": "<h2>Introduction</h2>\n<p>This post will describe some of the discussions surrounding TheDAO hack, how\nEthereum might soft-fork in a relatively safe manner, and how it relates to\nGnuclear, a novel proof-of-stake cryptocurrency with built-in governance to\naddress issues related to bugs and theft.</p>\n<h2>TheDAO Hack</h2>\n<p>An attacker (the hacker) has stolen more than 3.5mm ether (around $45mm) from\nthe DAO yesterday.  The attack <a href=\"http://vessenes.com/deconstructing-thedao-attack-a-brief-code-tour/\">is described\nhere</a>.</p>\n<p>Since then, the <a href=\"https://blog.ethereum.org/2016/06/17/critical-update-re-dao-vulnerability/\">Ethereum\nFoundation</a>\nhas asked the community to decide on whether they want to soft-fork to freeze\nthe funds of the hacker.  The Parity and Geth clients have released (differing?)\nupdates that let the miner choose whether to soft-fork, or not.  Furthermore,\n<a href=\"http://Slock.it\">Slock.it</a> has come out with a\n<a href=\"https://twitter.com/jaekwon/status/744609177738219520\">counter-attack</a> against\nthe hacker.</p>\n<p>Meanwhile, the community is arguing about the pros and cons of a soft-fork, and\na hard-fork to return the funds, or <a href=\"https://twitter.com/crainbf/status/743842869010665472\">negotiating-with/extorting the\nhacker</a> to return most of\nthe funds without a hard-fork.  An <a href=\"http://pastebin.com/CcGUBgDG\">open letter</a>\nas well as an\n<a href=\"https://www.cryptocoinsnews.com/exclusive-full-interview-transcript-alleged-dao-attacker/\">interview</a>\nallegedly from the hacker is circulating in the web discussing\nplausibly-deniable bribes against the miners to prevent a soft-fork at all, but\nso far there had been no cryptographically verified messages from the hacker.</p>\n<p>A soft-fork to freeze the hacker’s child DAO would buy the community more time\nto decide on a more permanent course of action, whether it is to hard-fork to\nreturn the funds, to freeze the funds indefinitely, to “negotiate” or extort the\nhacker to return most of the funds, or to let the hacker keep the funds.</p>\n<p>Either way, a soft-fork already undermines the stated premise of Ethereum</p>\n<p><em>“Ethereum is a decentralized platform for applications that run exactly as\nprogrammed without any chance of fraud, censorship, or third-party influence”</em> -\n<a href=\"https://twitter.com/oditorium/status/744421990103134208\">ethereum.org</a></p>\n<p>So, Ethereum is in a difficult position where it must either let the hacker get\naway with the theft of TheDAO’s ether, or, undermine its stated premise.  The\narguments in favor of mitigating the hack is clear. Few in the Ethereum\ncommunity really want 5% of the entire token supply of Ethereum to go to the\nhacker – the actual DAO experiment hadn’t even begun!  And yet, a coordinated\naction to reverse the attack or freeze the stolen funds is to undermine\nEthereum’s stated premise.  Some argue that to do so would destroy the very\npurpose and value of Ethereum.</p>\n<h2>What Ethereum Could Do</h2>\n<p>There are four parties involved in TheDAO attack.</p>\n<ul>\n<li>The DAO token holders (DTH)</li>\n<li>The ether holders</li>\n<li>The Ethereum miners</li>\n<li>Everyone else</li>\n</ul>\n<p><em>The DAO token holders (DTH)</em> are quite obviously the victim of this tragedy.\n<em>The ether holders</em> are necessarily involved because most of the suggested\ncourses of action start with a soft-fork to freeze the attacker’s funds\ncurrently held locked in the child DAO.  Ultimately, whether any soft-fork or\nhard-fork will happen at all hinges on the support from the <em>Ethereum miners</em>,\nthough theoretically they are incentivized to follow the will of the community.\n<em>Everyone else</em> is composed of the greater cryptocurrency community, including\nthose who are actively attempting to harm the system.</p>\n<h3>The DAO Wars</h3>\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\"\ndir=\"ltr\">&quot;The future is happening fast. Hacker wars around the largest\ndecentralized organisation in the world.&quot; <a\nhref=\"https://twitter.com/hashtag/DAOwars?src=hash\">#DAOwars</a> <a\nhref=\"https://t.co/f7zO3s1D6N\">pic.twitter.com/f7zO3s1D6N</a></p>&mdash; Simon\nde la Rouviere (@simondlr) <a\nhref=\"https://twitter.com/simondlr/status/744926345679994881\">June 20,\n2016</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<br />\nFirst of all, it should be noted that both Bitcoin and Ethereum themselves are\nDAOs, just as TheDAO is.  Some claim that Bitcoin and Ethereum are in\ncompetition with each other.  Thus, the Ethereum community would be wise to note\nthat there is probably a distributed Sybil attack in social media to confuse\nEthereum while it is vulnerable.\n<p>In short, any discussion in social media concerning what Ethereum &quot;ought to do&quot;\nor any comments about what will or will not happen to Ethereum with any\ndecision, ought to be taken with a grain of salt.  Any polling of the Ethereum\ncommunity should be done via cryptographic signatures from current ether\nholders.  Any polling of the Ethereum miners should be done via the mining\nprocess.</p>\n<h3>The Intention of TheDAO Investors</h3>\n<p>It’s pretty obvious that the “feature” that enabled the hacker to abscond with\nTheDAO’s ether was indeed a bug.  Arguments that it isn’t a bug generally point\nto two things: the text of TheDAO’s terms and conditions, and the stated premise\nof Ethereum.  For the former, we point the reader to <a href=\"http://www.bloomberg.com/view/articles/2016-06-17/blockchain-company-s-smart-contracts-were-dumb\">this nuanced\narticle</a>,\nand we accept that the latter premise is flawed – more on that later.</p>\n<p>The participants of TheDAO experiment were interested in seeing the investment\nmechanics – as written in English by the <a href=\"https://download.slock.it/public/DAO/WhitePaper.pdf\">Slock.it team’s DAO\nwhitepaper</a> – unfold as a\nsocial and cryptoeconomic experiment.  There were plenty of precautions taken to\nensure that the DAO contract code was bug-free, and so many in the DTH weren’t\nexpecting the funds to get drained before a single real proposal had a chance to\nsee the light of day.</p>\n<p>To find out, one could simply ask the DAO holders or the original funders with\nan on-chain or off-chain poll (with cryptographic signature verification, of\ncourse).  However, noone is actually challenging the assumption that the DTH\nwould vote in favor of a statement that claims that they were victims of grand\ntheft token.</p>\n<h3>Too Big to Fail</h3>\n<p>Some say that TheDAO should not be rescued for the same reasons why we shouldn’t\nbail out banks.</p>\n<p>Comparing the rescue of TheDAO to the oligopoly of the too-big-to-fail US banks\nis a stretch.  The analogy would be better had if TheDAO failed due to bad\ninvestments, or if it had somehow turned into a ponzi scheme.  But that is not\nthe case here.  The very mechanism that was designed to protect the DTH were\nunexpectedly used against them.  If any bank (or the Fed) were to roll back\ntheir database after getting hacked in a singular event, as long as it could do\nso and recover cleanly, nobody would complain that the bank were rescued.</p>\n<h3>Moral Hazard - Tyrrany of the Majority</h3>\n<p>Some argue that a soft-fork or hard-fork would bring about dangerous moral\nhazard, that rolling back the hacker’s stolen ether is a case of the majority\nexpropriating a minority.</p>\n<p>This is mostly a matter of perspective.  Once we drop Ethereum’s original\npremise, it becomes apparent that the former argument’s logical extreme would\nmake the absurd claim that the “acquisition” of tokens via theft of private keys\nat gunpoint would also constitute fair-game.  That’s perfectly fine as a\npersonal subjective philosophy, but if society as a whole decides to counteract\ntheft, the might of society is likewise justified.</p>\n<p>In this light, not returning the stolen funds might be a case of a minority\nexpropriating a majority.</p>\n<h3>Moral Hazard - Slippery Slope</h3>\n<p>Some argue that once you allow one contract to be rolled back, you open\nPandora’s box to allow anything to be rolled back. For example, a nation-state\nor powerful interest might compel the Ethereum Foundation to censor legitimate\ntransactions with no victim at all.</p>\n<p>The way to get around this problem is to require a majority consensus from the\nremaining ether holders.  For most issues that people would want a roll-back\nfor, the ether holders would likely vote against the measure.  But in the cases\nwhere a large chunk of the tokens are at stake, the remaining ether holders may\nprefer to allow for such a roll-back, if the alternative is deemed worse.</p>\n<p>However, there’s an obvious problem with this solution.  It would be very\ndifficult to get a significant quorum of ether holders to vote for anything at\nall, because there’s no expectation for ether holders to be active in voting for\nproposals.  The miners are a more active group, but they aren’t necessarily\nrepresentative of the community of ether holders.</p>\n<p>While not perfect, here’s a sketch of what could be done for this issue and for\nfuture issues in Ethereum 1.0:</p>\n<h4>Polling the Ether Holders</h4>\n<ol>\n<li>\n<p>First, construct a well written proposal that proposes a soft-fork to freeze\nthe hacker’s child DAO.  Come up with a reasonable deadline for voting, like\n1 week. Post this proposal on social media.</p>\n</li>\n<li>\n<p>Program a simple smart contract that accepts a signed transaction by ether\nholders. For the sake of our collective sanity this contract won’t accept any\nether.  It doesn’t even have to record anything in its state.  The user votes\nwith voting-power in proportion to their ether holdings.  Only simple accounts\ncan vote.</p>\n</li>\n<li>\n<p>Right after the deadline, for all the accounts that have voted, note the\namount of ether left in their account and count that toward the vote’s total\ntally.  This must be done atomically at a single block-height, otherwise users\nmight vote more than once with the same coins.  Note that this requires off-line\nchain-scanning and computation.</p>\n</li>\n</ol>\n<p>The result is a poll of the ether holders.  It is far from perfect,\nbecause a lot of users won’t vote, and, ether held in complex contracts won’t\nget any votes.  Also, it presupposes agreement about where to vote.  But just\nmaybe, if enough ether holders vote (e.g. more than 25% of all ether) and there\nis a super-majority (e.g. more than 67% in favor of a soft-fork, of those who\nvoted), then it seems prudent to consider that to be a vote by the Ethereum\ncommunity in favor of a soft-fork.</p>\n<h4>Coordinating the Ethereum Miners</h4>\n<p>Next, the miners should follow the will of the Ethereum community and prepare\nfor a soft-fork.  Miners could be required to announce their readiness for a\nsoft-fork in each block.  Once a sufficient supermajority has been reached (e.g.\n67% or more) in a window of say 12 hours, all the miners can activate their\nsoft-fork logic.  For safety, it’s important that all the miners agree on the\nexact behavior of this soft-fork, and that they only soft-fork once a\nsupermajority quorum has been reached.</p>\n<h4>Preventing Spam</h4>\n<p>There is still the question of why TheDAO should get special attention while\nlesser contracts with much less value at stake might get ignored.  Ideally there\nis a permissionless way to bring up all such matters to the attention of the\ncommunity, but since community engagement of this sort is quite expensive – one\ncould calculate how many man-hours are necessary to evaluate each proposal –\nmaybe there ought to be a market or fee mechanism to determine what deserves the\nchance of a soft-fork freeze or a hard-fork roll-back.</p>\n<h3>After the Soft-Fork</h3>\n<p>After a soft-fork, if there is one, I would argue that the community should\nnegotiate with the hacker to get back most of the funds, and let the hacker keep\na small portion like, like 8%.  Some people argue that the hacker deserves all\nof the stolen tokens.  Others argue that the hacker shouldn’t be incentivized\nany further because they already had control over the timing of market forces\n(e.g. they could have shorted the market just prior to the attack).  My opinion\nis that we should by default reward hackers a small amount for finding\nvulnerabilities, as long as they “voluntarily” return the vast majority of the\nstolen funds.  A social contract to reward hackers a small amount would be akin\nto enabling an automated penetration-testing bounty system, and would likely\naccelerate security improvements, rather than hinder it.</p>\n<p>To allow all such hackers to keep all of their stolen funds, in general, is to\nsubject ourselves to the existing power structures that be, e.g.  to\nnation-states with immense intelligence capabilities like the NSA.  It’s great\nthat we have a cryptocurrency whose premise is based on extreme crypto-anarchy\n(Bitcoin), but, if we allow all of our cryptocurrency systems to be coopted by\nthe same technocratic bias, we deserve what we get.  On the other hand, if we\ndon’t reward hackers sufficiently, we risk creating a fragile house of cards.</p>\n<h2>What About the Premise?</h2>\n<p>Ethereum’s original premise was destined to change.</p>\n<p><em>“… a decentralized platform for applications that run exactly as\nprogrammed without any chance of fraud, censorship, or third-party influence”</em></p>\n<p>Such a thing cannot exist in practice.  Fraud happens at all levels, especially\nat the human level.  For all we know, this whole DAO heist could have been\npremedidated all along – though the creators should be given the benefit of the\ndoubt.  Private keys can be swindled.  If there is a sudden influx of legitimate\ntransactions, the system can be coerced into dropping the majority of\ntransactions.  And there is always a chance of third-party influence.</p>\n<p>Some argue that dropping this premise would undermine the entire purpose, and\ntherefore the value, of Ethereum.  That’s hogwash.  There’s great value to be\nhad in a system that allows for the execution of contracts written as code.\n<em>Code as Law</em> doesn’t have to mean that the code cannot be revised if it is\nfound to be buggy, in the same way that many existing legal jurisdictions look\ninto the intent of contracts, in the case of typos or mistakes – code doesn’t\nneed to be any different.  Ethereum lets us write contracts in Solidity, to be\ninterpreted by a virtual machine, rather by an army of expensive lawyers.\nAllowing for deliberated roll-backs does not take that value away.  On the\ncontrary, it would strengthen the Ethereum community.</p>\n<p>Finally, it could be argued that the original premise of <em>unstoppable code</em> is\n<a href=\"https://medium.com/@lemurvanstar/immutability-of-any-blockchain-is-an-unrealistic-attempt-at-perfection-that-will-never-be-possible-4e4fcae59804\">not\ndesirable anyways.</a></p>\n<h2>An Alternative System</h2>\n<p>Here we describe <a href=\"https://github.com/gnuclear/gnuclear-whitepaper\">Gnuclear</a>,\nalternative cryptocurrency with a governance system baked in that can address\nissues of theft or bugs in a more streamlined and defined way.  Gnuclear is a\nproof-of-stake cryptocurrency powered by Tendermint BFT consensus.</p>\n<h3>A Different Premise</h3>\n<p>First, we start with a different premise.</p>\n<p><em>Gnuclear is a multi-asset, scalable, proof-of-stake-2.0\ncryptocurrency run by stakeholders, for the benefit of stakeholders</em>.</p>\n<p>There’s no magic here, just a straight up business run by a distributed set of\nstakeholders using a BFT consensus algorithm.  There are no impossible\nguarantees, and everything is up for change.  If you don’t like it, you don’t\nhave to use it.  If the stakeholders come to a deadlock due to disagreement,\nthey will have all the information they need to split, thanks to its design\nprinciple of transparency and accountability.</p>\n<p>Stated a different way, the thesis of Gnuclear (and Tendermint) is that we can\ncreate distributed autonomous organizations built on accountable BFT blockchain\nsystems that are self-incentivized and antifragile.</p>\n<h3>The Freedom to be Permissioned</h3>\n<p>Centralized (non-blockchain) organizations usually function in a permissioned\nway.  With a few exceptions, corporations get to select who they want to allow\ninto their organizations.  There are valid arguments for and against such\nself-interested discretion, but those who argue in favor of Laissez-faire\ncooperation often use economic competitiveness as justification. There’s no\nreason to think that the same can’t work in a blockchain environment, where\nvalidators in a proof-of-stake system must be permissioned into the network by\nsome form of consensus.</p>\n<p>Besides permissioning of its validators and stakeholders, a distributed ledger\ncan use permissioning at the application-logic level to create a better curated\nand <em>well regulated</em> system for the benefit of its users.  For example, imagine\nthat each top-level contract in Ethereum has a mandatory field specifying which\nregulatory group (similar to TheDAO’s curators) can decide on whether the spirit\nof the contract had been violated by bug or by theft.  Then, for the benefit of\nthe ledger’s less-sophisticated users, the stakeholders may wish to whitelist\ncertain regulatory groups at the system level.</p>\n<p>This field could be left <em>null</em> if the contract developers wanted to explicitly\nallow for absolute no roll-backs, but at least there would be a standard so that\nclient-software can inform the user about the consequences of sending money to\nthat contract – like when visiting a website with a broken cert.</p>\n<p>Note that this not analogous to arguing for a walled-garden internet.  The\ninternet is composed of many independent domains with differing strategies on\nmembership and permissions, and this has proven to be immensely valuable,\nenabling a Cambrian explosion of strategies.  Nor is this analogous to arguing\nin favor of a federation of data-silos.  Blockchains depend on transparency for\ntheir security.  A federation of permissioned and unpermissioned distributed\nledgers is not at all like a federation of data-silos.</p>\n<p>Think of blockchains as sovereign transparent ecosystems, and the stakeholders\nof a blockchain as independent entities that are self-incentivized to make that\nblockchain succeed, in a sea of competing ledgers.  Permissioning may be a\nsuperior strategy for winning market-share in certain niches.</p>\n<h3>Proof-of-Stake on Tendermint</h3>\n<p>Gnuclear is powered by Tendermint’s BFT consensus algorithm, and is thus is\nspecially designed for classical BFT consensus.</p>\n<p>For example, it’s a known fact that in a non-synchronous environment (read: in\nthe real world with faulty networks), no consensus algorithm can tolerate more\nthan 1/3 of Byzantine actors.  This means that if 1/3 or more validators are\nByzantine, they could halt or fork the blockchain ledger.  Satoshi Nakamoto\nwrote that Bitcoin can handle up to 1/2, but that only works because clients are\nsuppose to wait on the order of an hour for confirmation, thereby allowing the\nnetwork to be modeled as a (slow) fully-synchronous system.  In other words, if\nyou want a distributed ledger that can commit transactions to finality quickly\n(on the order of seconds), Tendermint offers an optimal solution.</p>\n<p>More information on how to solve the nothing-at-stake problem and the long-range\nforking problem are documented in the <a href=\"https://github.com/gnuclear/gnuclear-whitepaper#preventing-long-range-attacks\">gnuclear\nwhitepaper</a>.</p>\n<h4>Gnuclear Governance</h4>\n<p>That a 1/3 coalition of Byzantine voting power can halt the network in\nTendermint necessitates an interesting governance model in Gnuclear in order to\nprevent halts from happening, which would result in decreased revenue and\nconfidence in the ledger.  In other words, since a 1/3 coalition can temporarily\nhalt the ledger, it creates an incentive for the stakeholders to find a\ncompromise.</p>\n<p>The Gnuclear proposal system polls the stakeholders to see what they would do if\nthe proposal were passed, and calls off the proposal if it appears that the\nproposal is contentious enough to cause a halt or filibuster.  Instead of\nactually halting the blockchain and punishing everyone, it imposes a slight\npenalty for everyone involved.</p>\n<blockquote>\n  <p>\n    For each proposal, voters may vote with the following options:\n  </p>\n  <ul>\n    <li>Yay</li>\n    <li>YayWithForce</li>\n    <li>Nay</li>\n    <li>NayWithForce</li>\n    <li>Abstain</li>\n  </ul>\n  <p>\n      A strict majority of Yay or YayWithForce votes (or Nay or NayWithForce votes)\n    is required for the proposal to be decided as accepted (or decided as failed),\n    but <sup>1</sup>&frasl;<sub>3</sub>+ can veto the majority decision by voting\n    with force.  When a strict majority is vetoed, everyone gets punished by losing\n    <code>VetoPenaltyFeeBlocks</code> (DEFAULT 1 day&rsquo;s worth of blocks) worth\n    of fees (except taxes which will not be affected), and the party that vetoed the\n    majority decision will be additionally punished by losing\n    <code>VetoPenaltyQuarks</code> (DEFAULT 0.1%) of its quarks.\n  </p>\n  <footer>\n    - <em><a href=\"https://github.com/gnuclear/gnuclear-whitepaper#governance\">on Gnuclear governance</a></em>\n  </footer>\n</blockquote>\n<p>It’s interesting to compare this to the 1/2 or 2/3 required quorum for different\ntypes of proposals in various existing governance systems.  In Gnuclear, it’s a\nunified system – a simple majority is sufficient to pass any measure, unless\nthere is a simultaneous veto by a 1/3 minority.</p>\n<h4>Need for a Constitution</h4>\n<p>Some things can’t be easily automated as code.  For example, determining:</p>\n<ul>\n<li>whether theft has occurred</li>\n<li>whether sophisticated DDoS attacks are happening</li>\n<li>whether a contract threatens the integrity of the ledger that it’s in</li>\n<li>whether a contract threatens the integrity of other systems or beings</li>\n<li>how to change the incentive strategy in the face of changing economic\ncircumstances</li>\n<li>how to react to other extrinsic circumstances</li>\n</ul>\n<p>For these issues, the Gnuclear governance system lets stakeholders vote on\nhuman-readible proposals called TextProposals.</p>\n<p>Given such freedom in what can be decided by humans, even the best governing\nstructures cannot prevent the system from disintegrating if the constitutents\ncannot agree on process.  A breakdown of communication or understanding can\nquickly lead to a breakdown of live-consensus, and ultimately can lead to a\nblockchain halt or split.</p>\n<p>For this reason, there needs to be a written constitution, or a human-protocol,\nthat must be followed.  In the very least, the constitution must contain the\nfollowing:</p>\n<ul>\n<li>Validators must execute the blockchain protocol decided on by consensus.</li>\n<li>This constitution may be amended by passing a TextProposal.</li>\n</ul>\n<p>Different ledgers may have additional elements in their constitution.  For\nexample, the constitution may provide guidance on what constitutes a theft or\nbug, and how to deal with it.  Or, it may say that no validator may disuss\nsoft-forks or roll-backs.  It won’t guarantee that the validators won’t actually\nsoft-fork the ledger, but it does allow the ledger to specialize and attract\nstakeholders with compatible interests.</p>\n<h4>Stake Delegation</h4>\n<p>In Gnuclear proof-of-stake, there are three groups to consider: the validators,\nthe staked delegators, and the non-staked token holders. The validators get to\nvote on any proposal (in fact, they must vote to avoid incurring a penalty). By\ndefault the delegators inherit the vote of the delegated validators, but\ndelegators can override the vote manually.</p>\n<p>Non-staked token holders who aren’t putting their tokens at stake (and thus are\nnot participating in the consensus process) do not get to vote on proposals.  In\na future post we’ll discuss the pros and cons of this design decision.</p>\n<h4>Accountability and Reputation</h4>\n<p>A major benefit of the Gnuclear proof-of-stake system over any proof-of-work\nsystem is about accountability and reputation.</p>\n<p>Take for example, the alleged hacker’s plan to <a href=\"https://www.cryptocoinsnews.com/exclusive-full-interview-transcript-alleged-dao-attacker/\">bribe Ethereum\nminers</a>\nto prevent a soft-fork.  Though this threat has little credibility until\ncryptographic evidence is published, the hypothetical threat is real.  Since\nproof-of-work miners are completely anonymous with no associable stake in the\nsystem, there’s not a whole lot that could be done to prevent such a bribe,\nexcept to bribe even more. Furthermore, there is little incentive for the miners\nto be enganged in these political issues, so the alleged hacker’s note about\nplausible deniability is also real.</p>\n<p>In Gnuclear, these issues resolved, because stakeholders are pseudonymous with\nassociated stake, and validators are required to vote on all proposals.</p>\n<p>This pseudonymous reputation system also enables true antifragility. A\nblockchain split in a proof-of-stake blockchain is very different than a\nblockchain split in a proof-of-work blockchain.  In a proof-of-work blockchain,\nnobody rational would follow a fork with less than 50% of the mining power\nbehind it because it would be vulnerable to attack by anonymous miners <em>unless\nthere were also a change in the hashing algorithm that required an investment in\ndifferent kinds of hardware</em>.  In Tendermint proof-of-stake, a blockchain split\ncan result in increased security for both child blockchains.</p>\n<p><em>For a related explantion of Tendermint’s fork-accountability, refer to the\nGnuclear whitepaper section on <a href=\"https://github.com/gnuclear/gnuclear-whitepaper#consensus\">Tendermint\nconsensus</a>.</em></p>\n<h3>Conclusion</h3>\n<ul>\n<li>It’s people all the way down.</li>\n<li>Ethereum doesn’t have to cater to extremists.</li>\n<li>Either way, lets create a diverse ecosystem of antifragile distributed\nledgers.</li>\n<li>Check out <a href=\"http://github.com/gnuclear/gnuclear-whitepaper\">Gnuclear</a> and <a href=\"http://forum.tendermint.com:3000/\">join\nthe discussionsi</a>!</li>\n</ul>\n",
    "description": "",
    "dateFriendly": "June 21, 2016"
  },
  {
    "title": "A Critique of Merkle's DAO Democracy: Making it Reliable",
    "slug": "a-critique-of-merkle-s-dao-democracy-making-it-reliable",
    "date": 1465142400000,
    "body": "<h2>Merkle’s New DAO Paper</h2>\n<p>I’ve been looking for a paper that criticizes futarchy that specifically\naddresses the thin-market and corresponding manipulation and feedback problems\nthat my gut tells me there is.  I haven’t found it yet, but I did stumble upon\nwhat may be a solution to it.</p>\n<p><a href=\"http://merkle.com/papers/DAOdemocracyDraft.pdf\">Link to the paper</a></p>\n<p>While giving it a proper read, I noticed part way through that it includes a\nsection that attempts to address the problem of securing a blockchain ledger\nusing prediction markets.</p>\n<p>I predict that a general prediction market will find that a PoS system on\nTendermint will be favored over the BFT validator-set selection system as\nproposed by Merkle.</p>\n<blockquote>\n<p>\nBreaking the system requires sneaking past a fully functioning and well financed\nprediction market that is actively looking for any attack and which is running\nas a distributed algorithm on a set of core servers that are fully protected\nfrom any attack. Any slightest hint of any attack that might actually be\nsuccessful on any core server <b>will result in its immediate removal from the\npool of core servers</b>, and its replacement with any one of a large number of\nconstantly running alternate servers. Any strategy for better protecting the\ncore servers, or for better detecting an attack, will be immediately adopted\n(thanks to a prediction market specifically aimed at improving security which is\nconstantly evaluating new and better strategies). It will be hard to corrupt\neven a few core servers, let alone half of them. Yet half of them (and possibly\nmore) would have to be corrupted before it would even be possible to gain\ncontrol of the system and corrupt the prediction market.\n</p>\n<footer>- Merkle in \"DAOs, Democracy and Governance\"</footer>\n</blockquote>\n<p>The problem with futarchy, which is not the same problem with prediction\nmarkets, is that in a futarchy, the prediction market is used to make a decision\nthat can have arbitrary impact.  In other words, <b>a futarchy is a prediction\nmarket plus feedback</b>.  In order to have futarchy be a good method of\ngovernance, not only do <b>you need a good prediction market free of noise by\nvirtue of being sufficiently capitalized</b>, <b>you also need to ensure the\nprediction market cannot be manipulated to make a decision that yields an\nundesirable result</b> (but still creates a positive ROI for the manipulator).</p>\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\"><a\nhref=\"https://twitter.com/paulg\">@paulg</a> Noise in thin markets?</p>&mdash;\nBram Cohen (@bramcohen) <a\nhref=\"https://twitter.com/bramcohen/status/739261628303081472\">June 5,\n2016</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<p>I think the first part of Merkle’s paper addresses this problem by giving each\nperson a vote of 0 to 1, assuming that bribing attacks can be mitigated.  But\nthe section entitled “Making it Reliable” which uses the prediction market to\ndecide on the validator set, does not prevent manipulation.</p>\n<p>First, Merkle’s proposal makes it impossible to determine the true outcome of\nthe fitness of a validator, because the outcome of the prediction market that\nassesses the fitness of the validator makes a decision to remove that validator\nfrom the validator set if it is deemed insecure.  <b>Once you make a decision to\nremove a validator, you’ve removed the incentive for that validator to perform\ncorrectly at all</b> – at least if you want financially sustainable blockchain\nsecurity.  To secure a validator requires investment in internet/power/compute\ninfrastructure, to invest in good op-sec, to pay the bills and salaries, etc.  A\nfinancially sustainable blockchain should only compensate those validators that\nhave a reasonable expectation of being secure, and if the prediction market says\notherwise, it should not be compensated.</p>\n<p>Well, if you dis-incentivize a validator, it will fail, so letting the\nprediction market dictate whether a validator should be allowed membership in\nthe validator-set of a blockchain opens it up to arbitrary feedback, and thus\nmanipulation.</p>\n<p>Second, a secure validator shouldn’t be leaking much information about its\nweaknesses for the prediction market to make judgements on.  Security in\nvalidating is about operational-security of human resources, of source-code, of\ncompute hardware, and of internet/power reliability.  The best judge of one’s\nability should be oneself – if a validator has resources to invest in either\nimproving its operational-security or bonding more stake, it should be able to\nmake the best judgement about where to allocate capital.  Meanwhile, it should\ninvest in preventing any information leaks about its weaknesses to the public!</p>\n<p>Likely, any vulnerability in a mature validator-set will be ones that were\ndifficult to detect, like a needle in a haystack.  The validators are their own\nbest predictors of their own vulnerabilities, if additional stake can be\npurchased in the market.</p>\n<p>Fortunately, I think we can use the prediction market to help make blockchains\nreliable.  You can make a prediction market based on the high-level\noperational-security strategy choices made by validators (such as the\noperating-system used, etc), if any such information can be compelled to be\ntruthfully published, and use the outcome of the prediction market to tweak the\nrelative sizes of quorums of the disparate strategies – and otherwise let the\nstrategies play out unless proven inferior.  This minimizes the effect of the\ndecision swaying the measured outcome.</p>\n<p>Could you also use the prediction market to practically decide on the overall\nconsensus strategy?  Maybe, if the prediction were about the security of the\nblockchain as a whole, and that prediction weren’t used to make any decisions\nthat might impact the incentive structure of the blockchain once the consensus\nstrategy is chosen. In other words, I think we just need to experiment with\nself-incentivized blockchains.</p>\n",
    "description": "A critique of the subsection of the new DAO paper by Merkle, specifically of the section entitled 'Making it Reliable'",
    "dateFriendly": "June 6, 2016"
  },
  {
    "title": "TMSP: The Tendermint Socket Protocol",
    "slug": "tmsp-the-tendermint-socket-protocol",
    "date": 1450454400000,
    "body": "<blockquote>\n<p>After you read this post, don’t forget to check out our tutorials!  They also appear at the end of this page.</p>\n</blockquote>\n<blockquote>\n<ol>\n<li><a href=\"/tutorials/run-your-first-tmsp-application/\">Run your first TMSP application</a></li>\n<li><a href=\"/tutorials/launch-a-tmsp-testnet/\">Launch a TMSP testnet</a></li>\n</ol>\n</blockquote>\n<h2>Motivation</h2>\n<p>Thus far, all blockchains “stacks” (such as <a href=\"https://github.com/bitcoin/bitcoin\">Bitcoin</a>) have had a monolithic design.  That is, each blockchain stack is a single program that handles all the concerns of a decentralized ledger; this includes P2P connectivity, the “mempool” broadcasting of transactions, consensus on the most recent block, account balances, Turing-complete contracts, user-level permissions, etc.</p>\n<p>This approach to blockchain development has several problems.  First, creating a new blockchain requires forking an existing blockchain stack, and this comes with the cost of complexity.  First you need to understand all the components of a blockchain stack, even those that aren’t directly relevant to the logic of your application.  This is especially true when the codebase is not modular in design and suffers from “spaghetti code”.</p>\n<p>Another problem with this approach is that it limits you to the language of the blockchain stack (or vice versa).  In the case of Ethereum which supports a Turing-complete bytecode virtual-machine, it limits you to languages that compile down to that bytecode; today, those are Serpent and Solidity.</p>\n<p>In contrast, our approach is to decouple the consensus engine and P2P layers from the details of the application state of the particular blockchain application.</p>\n<h2>Intro to TMSP</h2>\n<p><a href=\"https://github.com/tendermint/tendermint\">Tendermint Core</a> (the “consensus engine”) speaks to the application via a socket protocol called <a href=\"https://github.com/tendermint/tmsp\">TMSP</a>.</p>\n<p>To draw an analogy, lets talk about a well-known cryptocurrency, Bitcoin.  Bitcoin is a cryptocurrency blockchain where each node maintains a fully audited Unspent Transaction Output (UTXO) database. If one wanted to create a Bitcoin-like system on top of TMSP, Tendermint Core would be responsible for</p>\n<ul>\n<li>Sharing blocks and transactions between nodes</li>\n<li>Establishing a canonical/immutable order of transactions (the blockchain)</li>\n</ul>\n<p>The application will be responsible for</p>\n<ul>\n<li>Maintaining the UTXO database</li>\n<li>Validating cryptographic signatures of transactions</li>\n<li>Preventing transactions from spending non-existent transactions</li>\n<li>Allowing clients to query the UTXO database.</li>\n</ul>\n<p>Tendermint is able to decompose the blockchain design by offering a very simple API between the application process and consensus process.</p>\n<p>The API consists of 3 primary message types that get delivered from the core to the application.  The application replies with corresponding response messages.</p>\n<p>The messages are specified here: <a href=\"https://github.com/tendermint/tmsp#message-types\">https://github.com/tendermint/tmsp#message-types</a></p>\n<p>The <code>AppendTx</code> message is the work horse of the application.  Each transaction in the blockchain is delivered with this message. The application needs to validate each transactions received with the <code>AppendTx</code> message against the current state, application protocol, and the cryptographic credentials of the transaction. A validated transaction then needs to update the application state — by binding a value into a key values store, or by updating the UTXO database.</p>\n<p>The <code>CheckTx</code> message is similar to <code>AppendTx</code>, but it’s only for validating transactions.  Tendermint Core’s mempool first checks the validity of a transaction with <code>CheckTx</code>, and only relays valid transactions to its peers.  Applications may check an incrementing nonce in the transaction and return an error upon <code>CheckTx</code> if the nonce is old.</p>\n<p>The <code>Commit</code> message is used to compute a cryptographic commitment to the current application state, to be placed into the next block header. This has some handy properties. Inconsistencies in updating that state will now appear as blockchain forks which catches a whole class of programming errors. This also simplifies the development of secure lightweight clients, as Merkle-hash proofs can be verified by checking against the block hash, and the block hash is signed by a quorum of validators.</p>\n<p>There can be multiple TMSP socket connections to an application.  Tendermint Core creates two TMSP connections to the application; one for the validation of transactions when broadcasting in the mempool, and another for the consensus engine to run block proposals.</p>\n<p>It’s probably evident that applications designers need to very carefully design their message handlers to create a blockchain that does anything useful but this architecture provides a place to start.</p>\n<h2>A Note on Determinism</h2>\n<p>The logic for blockchain transaction processing must be deterministic.  If the application logic weren’t deterministic, consensus would not be reached among the Tendermint Core replica nodes.</p>\n<p>Solidity on Ethereum is a great language of choice for blockchain applications because, among other reasons, it is a completely deterministic programming language.  However, it’s also possible to create deterministic applications using existing popular languages like Java, C++, Python, or Go.  Game programmers and blockchain developers are already familiar with creating deterministic programs by avoiding sources of non-determinism such as:</p>\n<ul>\n<li>random number generators (without deterministic seeding)</li>\n<li>race conditions on threads (or avoiding threads altogether)</li>\n<li>the system clock</li>\n<li>uninitialized memory (in unsafe programming languages like C or C++)</li>\n<li><a href=\"http://gafferongames.com/networking-for-game-programmers/floating-point-determinism/\">floating point arithmetic</a></li>\n<li>language features that are random (e.g. map iteration in Go)</li>\n</ul>\n<p>While programmers can avoid non-determinism by being careful, it is also possible to create a special linter or static analyzer for each language to check for determinism.  In the future we may work with partners to create such tools.</p>\n<h2>Tutorials</h2>\n<p>Follow these tutorials to quickly get started developing your TMSP application.</p>\n<ul>\n<li><a href=\"/tutorials/run-your-first-tmsp-application/\">Run your first TMSP application</a></li>\n<li><a href=\"/tutorials/launch-a-tmsp-testnet/\">Launch a TMSP testnet</a></li>\n</ul>\n<h2>Contributions</h2>\n<p><em>Many thanks to Zaki Manian for providing the “Intro to TMSP” section</em></p>\n",
    "description": "TMSP lets you create blockchain application easily in any languge.  This post describes the motivation behind TMSP and links to tutorials.",
    "dateFriendly": "December 19, 2015"
  },
  {
    "title": "Tendermint for Fast Settlement",
    "slug": "tendermint-for-fast-settlement",
    "date": 1443801600000,
    "body": "<p>Some experts in the nascent blockchain industry have said the following:</p>\n<ul>\n<li>The blockchain is just a database_</li>\n<li><em>Blockchains don’t help with fast settlement</em></li>\n<li><em>The future of finance on the blockchain may not involve consensus</em></li>\n<li><em>You can build on top of the Bitcoin blockchain for fast settlement</em></li>\n</ul>\n<p>This short post will address these statements and paint a different picture.</p>\n<h3>Clearing and settlement woes</h3>\n<p>Clearing and settlement are separate but related terms.  The source of the differences stems from the significant duration of time (on the order of days) for the delivery of assets (e.g. paper certificates used to take over a week to deliver by courier).  A clearinghouse provides faster settlement between two trading parties by acting as the counterparty for both.</p>\n<p>So, it isn’t the clearing that is slow. Part of the purpose of clearing is to mitigate the slowness of settlement.  The reason why we don’t have fast settlement is because “Current banking databases are disparate and therefore require reconciliation between each other.”, and, “the existence of [3rd party] consortia … prevented banking systems from evolving, because there was no incentive for a single bank to create a better system outside of the consortia”  (<a href=\"https://medium.com/design-matters-4/blockchains-and-banks-cef72f0fcf29\">source</a>).  To solve the problem of reconciliation, we need a common ledger and platform.</p>\n<p>Once we have a common ledger, we can think about tradeoffs between security and settlement speed.  When settlement becomes fast on the order of seconds, human intermediation becomes difficult, which in turn means that we need the system to be as fault tolerant as possible.</p>\n<h3>The source of Bitcoin’s security</h3>\n<p>Bitcoin and Bitcoin’s proof-of-work (PoW) mining, or Nakamoto consensus, provides something that until 2008 had never existed before.  Bitcoin was the first open decentralized application to provide Byzantine fault-tolerant (BFT) consensus on a global currency ledger.  Nakamoto consensus is a novel BFT consensus algorithm that utilizes computational power as a proxy for membership.</p>\n<p>The security of Nakamoto consensus depends on extrinsic factors such as the availability of energy and access to semiconductor fabs.  Ignoring these factors, the security of Nakamoto consensus can be modeled by the makeup and diversity of the mining network.  The more diverse the mining participants, the more difficult it is to coordinate a sufficiently large coalition to successfully attack the network and cause double-spends. If we discount the difficulty of coordination (which may be prudent considering that major mining pools communicate with each other routinely), what’s left is the opportunity cost of producing blockchain forks–just 25 bitcoins per block at today’s inflationary reward schedule.</p>\n<p>The Bitcoin blockchain does help with settlement in that it provides a BFT ledger.  The problem is that Nakamoto consensus is slow and expensive, as its security is only proportional to the cumulative sum of energy burned over time.</p>\n<h3>Classical BFT enables additive security</h3>\n<p>Classical BFT consensus algorithms don’t rely on the opportunity cost of energy expenditure for security.  They use pseudonymous identities and cryptographic signatures to ensure that a sufficient quorum of participants approve of new transactions before they are committed.  These algorithms had been around since the 70’s and 80’s, and culminated in 1999 with the renowned PBFT algorithm.  Existing PBFT solutions are difficult to use or incomplete (<a href=\"http://arxiv.org/abs/1110.4854\">source</a>), so there is a need for a new free and open-source implementation.  Tendermint is such an open-source implementation of the PBFT consensus protocol (see <a href=\"http://tendermint.com/posts/tendermint-vs-pbft/\">explanation</a>).  Tendermint can commit blocks to finality on a global ledger with hundreds of validators on the order of seconds.</p>\n<p>Unlike Nakamoto consensus, there is no extrinsic opportunity cost for signing conflicting blocks on the blockchain, since cryptographic signatures are practically free. Instead, we can design classical BFT consensus protocols to be <em>accountable</em>; that is, <strong>when the blockchain is forked, we can review the signatures and determine which participants caused the fork to happen</strong>.  If we combine this BFT accountability with the concept of collateral, we get something that I’m calling <em>additive-security</em>.  Each individual participant of the BFT consensus process might only post a small amount of collateral (limited by their confidence in ability to secure their hardware and software), but <strong>the total effective collateral can be large</strong>.  For example, if there are 1000 validators that each post $1M worth of collateral, a double-spend attack would cost attackers at minimum $333M dollars ($1M × 1000 × ⅓).  By the way, we can increase the minimum fraction of collateral at stake (beyond ⅓) by requiring a larger quorum of validators to commit each block.</p>\n<p>A consortium of banks could run a Tendermint blockchain where the validators are publicly identified.  Each validator can post collateral secured by legal contracts with real assets held in escrow by each other, and/or with tokens intrinsic to the blockchain.  Each validator on such a blockchain network would secure their public/private key to the best of their ability.  To mitigate the risk of accidents and hacks, each validator keypair can be derived from multiple keypairs that produce signatures jointly using a cryptographic threshold signature scheme;  in effect, each validator node would be running a BGA consensus network recursively for additional security.  Tendermint validators uses the Ed25519 Schnorr signature scheme because it supports cryptographic threshold signatures (<a href=\"http://cacr.uwaterloo.ca/techreports/2001/corr2001-13.ps\">source</a>).  I’ll write more about this in a future post, but for now lets just say that, under this scheme, a single bank with a single effective public key on the main ledger could reasonably post billions of dollars in collateral.</p>\n<p>For public permissionless blockchains, Nielsen’s law of internet bandwidth is at play.  If we naively assume that doubling the number of validators requires four times the bandwidth, and that bandwidth doubles every two years, every four years a public blockchain can support twice as many validators (thus naively twice as much collateral) and still commit blocks at the same speed.  I bet we can do better.</p>\n<h2>Fin</h2>\n<p>With publicly identified Tendermint validators with collateral at risk, we can have a shared decentralized ledger that offers fast settlement.  This is a novel concept and one that has the potential to change the nature of banking itself.</p>\n",
    "description": "Blockchains provide new opportunities in fast settlement",
    "dateFriendly": "October 3, 2015"
  },
  {
    "title": "Tendermint vs PBFT",
    "slug": "tendermint-vs-pbft",
    "date": 1443801600000,
    "body": "<p>Tendermint was originally inspired by the DLS algorithm (<a href=\"http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf\">link</a>).  After several iterations to improve efficiency, (namely, making it more asynchronous), it has become quite similar to the PBFT algorithm (<a href=\"http://www.pmg.lcs.mit.edu/papers/osdi99.pdf\">link</a>).  This document serves to illustrate the similarities and differences between Tendermint and PBFT.</p>\n<p>|Tendermint     | PBFT              |\n|</p>\n",
    "description": "Tendermint is a variant of PBFT; similarities and differences explained",
    "dateFriendly": "October 3, 2015"
  },
  {
    "title": "Cases for Tendermint",
    "slug": "cases-for-tendermint",
    "date": 1442073600000,
    "body": "<p>You may have an application that benefits from blockchain technology, and you may be trying to figure out whether to build that on Bitcoin, some meta-coin protocol like Counterparty, with Solidity/Serpent on the Ethereum virtual machine, or on a new blockchain stack altogether.  Actually, you should seriously consider building on Tendermint.</p>\n<h2>A little background on Tendermint</h2>\n<p>Tendermint is not a fork of Bitcoin, NXT, Ripple, or Ethereum.  Tendermint is its own blockchain stack written from the ground up.  It was built to be the base blockchain stack from which to fork off of for a wide variety of decentralized applications.  It started back in 2014 as an ambitious project to solve the Bitcoin mining problem and bring real Byzantine fault-tolerant consensus to cryptocurrencies.  First we adapted an existing BGA consensus algorithm to make it suitable for blockchains.  For the actual implementation we considered forking Bitcoin, NXT, BitShares, and other projects, but none could easily accommodate the desired project architecture.  So, a brand spanking new blockchain stack was born.</p>\n<p>Tendermint offers:</p>\n<ul>\n<li>Byzantine fault-tolerant consensus with unparalleled speed and security guarantees – without mining. <a href=\"https://github.com/tendermint/tendermint/wiki/Byzantine-Consensus-Algorithm\">(see spec)</a></li>\n<li>A very clean codebase with clear separation of concerns – no spaghetti, thanks Golang!</li>\n<li>Throttled/fair P2P stack to handle multiplexed channels of communication.</li>\n<li>Clear P2P logic with the <a href=\"https://en.wikipedia.org/wiki/Reactor_pattern\">reactor pattern</a></li>\n</ul>\n<p>On top of this foundation, we’ve built more advanced blockchain features.</p>\n<ul>\n<li>A compatible and efficient Ethereum VM implementation</li>\n<li>A permissions system that works across accounts and VM contracts</li>\n</ul>\n<p>We’re going to build more exciting features going forward, except this time we’ll blog about it while we do it, so hang on to your metaphorical horses.</p>\n<h2>On Tendermint consensus</h2>\n<p>The consensus system is the foundational layer of any blockchain stack. It is the process by which all of the transaction validators (equivalent to miners in Bitcoin) agree on the state of the network.  Improvements in speed, security, and cost of a consensus system ripple up and improve the performance of any network or application built on top of it.  Let’s dive into some examples to get a sense of how it works.</p>\n<h3>Case 1: Payment verification</h3>\n<p>Say that your mobile phone is connected to untrusted wifi, and you’re making a business deal with Satoshi.  Satoshi just sent you a large payment, and you need to verify that this payment was committed onto the blockchain network irreversibly.</p>\n<p>With Bitcoin, you generally need to wait up to 6 confirmation blocks (about 1 hour, sometimes longer) to consider a transaction fully committed.  For very large payment transactions you should wait even longer, because the security afforded by the blockchain miners is no greater than the cost of double-spending that transaction, which is today only about 25 Bitcoins per reverted block, and soon to be half of that.</p>\n<p>With Tendermint, a global network of 1000 independent validators can commit a transaction in less than 60 seconds.  The time required to commit only gets shorter with increased bandwidth and computational capacity of the nodes of the network.  In the near future we’ll be able to commit transactions on a global Tendermint blockchain with more than 1000 validators in a matter of seconds – the only real limitation is the time it takes for light to travel around the globe.</p>\n<h3>Case 2: Name registry lookup</h3>\n<p>Similar to case 1, but instead of verifying a payment, you need to verify Satoshi’s public key as registered under the name “@satoshi” on a name-registry blockchain.  The difference here as compared to case 1 is that instead of verifying a new transaction, you’re verifying the current value of a pre-registered key that may have been changed by other transactions.</p>\n<p>With Bitcoin (and Namecoin), you can verify that “@satoshi” was registered with a particular public key at some point in the past, but you wouldn’t know whether the public key had since been updated without downloading the whole blockchain.  This is because the presence of a name-registration transaction in the blockchain does not imply that later transactions hadn’t updated the value for that key.  In order for you to efficiently check for the current value of a name, the blockchain should support a balanced Merkle tree on the most recent name-registry state.  Even if Bitcoin/Namecoin did support such a data structure, you would still have to download and verify all the blockchain hashes and headers, and if the value might have been updated recently you’re still vulnerable to a fork-censorship attack.</p>\n<p>With Tendermint, all you need is the most recent blockhash signed by more than 2/3 of the validators, and a Merkle proof that proves the current value associated with the name “@satoshi”.  You don’t even need to wait for a single commit.  If you’re interested, see <a href=\"https://github.com/tendermint/tendermint/wiki/Merkle-Trees#iavl-tree\">this link</a> for more information on our balanced binary Merkle tree implementation.</p>\n<p>In future posts I’ll go into detail about the consensus algorithm and how it can provide these unique speed &amp; security guarantees without proof-of-work mining.  For now, you can check the most recent Tendermint spec on the github wiki <a href=\"https://github.com/tendermint/tendermint/\">here</a>.</p>\n<h2>Tendermint architecture</h2>\n<img src=\"/images/tm_architecture.png\">\n<p>The diagram above is meant to show that:</p>\n<ul>\n<li>the consensus and transaction-execution (aka state-transition) modules are separate except for the shared (immutable/Merkle-ized) state.</li>\n<li>the consensus module takes a block, a commit for the block, and the last state, and uses the transaction-execution module to produce the next state.</li>\n<li>the VM call transaction is one of many transaction types offered by the transaction-execution module.</li>\n<li>the Ethereum VM (EVM) is only one of potentially many supported virtual machines.</li>\n</ul>\n<p>If you have a blockchain application in mind, on Tendermint there are two options to consider – a smart contract on the Ethereum VM (and in the future, other VMs as well), or, a native transaction type (like SendTx or NameTx above).</p>\n<h2>Whether to develop a VM smart contract or develop a native Tendermint contract</h2>\n<p>The main benefit of a Turing-complete VM on a blockchain is that anyone can upload new contract logic onto the blockchain.  This is especially true on big-bad-public-blockchains (BBPB) like Bitcoin or Ethereum which were designed to allow anyone to upload new contract logic.  On the other hand, private blockchains and consortium blockchains that are more tightly managed may not need or even want arbitrary user-defined logic.</p>\n<p>Sometimes, writing an EVM contract is the right answer.  Use the EVM if you need to deploy the contract on a public blockchain such as Ethereum.  Use the EVM if you don’t have systems programming experience, and you find that writing a solidity contract is easier than writing in Golang.  Use the EVM if your contract-logic is simple enough that you wouldn’t mind stepping over bytecode execution to debug your contract.</p>\n<p>For other applications where the former exceptions don’t apply, you probably want to write native code on Tendermint for a variety of reasons – Golang’s language tooling is better so debugging is easier, it’s computationally more efficient by far, and it removes two complex layers (one for the bytecode compiled language, and one for the VM itself).  If you want full control over your Merkle-ized data structures (e.g. without the 32-by-32-byte restriction of the EVM’s Patricia-trie) then you have to write your contract logic at the native level.  Tendermint provides you with the right tools to make this as easy as possible.</p>\n<h2>Fin</h2>\n<ul>\n<li>Go to <a href=\"http://tendermint.com\">http://tendermint.com</a> and sign up for the newsletter.</li>\n<li>Check out the <a href=\"https://github.com/tendermint/tendermint/wiki\">Tendermint wiki</a>.</li>\n<li>Develop on Tendermint.</li>\n<li>Email us at <a href=\"mailto:hello@tendermint.com\">hello@tendermint.com</a> with your full name to join our Slack channel.</li>\n</ul>\n",
    "description": "Why you should build on Tendermint, and whether to use the EVM",
    "dateFriendly": "September 13, 2015"
  },
  {
    "title": "Sidechains without Pegging",
    "slug": "sidechains-without-pegging",
    "date": 1416844800000,
    "body": "<p>There is an interesting debate happening between Bitcoin maximalists and the rest of the cryptocurrency community.</p>\n<p>First, BlockStream published Bitcoin maximalist paper on <a href=\"http://www.blockstream.com/sidechains.pdf\">sidechains</a>.\nThen, Dominic of Pebble responded with due <a href=\"http://blog.pebble.io/post/100702644738/on-sidechains-bitcoin-maximalism-and-freedom\">criticism</a>.\nVitalik of Ethereum responded with <a href=\"https://blog.ethereum.org/2014/11/20/bitcoin-maximalism-currency-platform-network-effects/\">more analysis</a>.\nAnd finally, Joel of Union Square Ventures wrote about a very <a href=\"http://joel.mn/post/103546215249/the-blockchain-application-stack\">Bitcoin maximal world</a>.</p>\n<p>I’d like to add a few points to this conversation.</p>\n<p>First, let’s get this out of the way.  Metacoins like Counterparty are a nuisance for Bitcoin, regardless of the merits of the Counterparty protocol itself.  They benefit by taking advantage of the Bitcoin consensus network.  They bloat the block-chain space with transactions that aren’t relevant to other Bitcoin users.  The security of the Counterparty system is dependent on the security of Bitcoin’s, while it’s entirely possible that the market cap of assets in Counterparty become higher than that of Bitcoin, creating a lopsided security threat.  Metacoins will phase out as it becomes easier to bootstrap a secure coin with a pre-built consensus engine (such as Tendermint) that doesn’t rely on proof-of-work.  When the valuation of Bitcoin drops enough, Counterparty will be forced to migrate to its own block-chain too.</p>\n<p>The main thing I’d like to talk about is sidechains.  The term was first introduced by Bitcoin developers who were considering ways to encourage innovation in the alt-coin space while cutting down on the speculation and volatility that results from bootstrapping a new coin ex nihilo, by 1-way or 2-way pegging.  It works by having one block-chain track the consensus state of another block-chain.  It’s no wonder that the term “sidechain” refers to two distinct concepts — interchain-communication and pegging.  I like the term for its succinctness, so I’m going to try to hijack it to mean only interchain-communication — with or without pegging.</p>\n<p>The beautiful thing about sidechains is that it’s more than currency pegging.  For example, it can be used to run a decentralized exchange between two currencies.  You can do this now with “cross-chain-transactions”, but it requires both parties to be online, or for both to trust a few “smart oracles” with threshold signatures to handle the trade.  But when your block-chain can track the state of another with sidechain technology, you don’t have to trust anyone except the cryptocurrency network, which you trust already.  If you trust a block-chain enough to hold coins in it, you should trust the block-chain to enforce your exchange orders for you when you want to trade with a sidechain.  So now you can bootstrap a currency <em>and</em> provide liquidity without trusted centralized exchanges, and really incentivize the development of new currencies without pegging the valuation onto <s>the Euro</s>Bitcoin.  It’s especially important to have sovereign unpegged market-priced block-chains if the very thing you want to experiment with is monetary policy.</p>\n<p>Sidechain technology is more than 1-way or 2-way pegging to Bitcoin. It’s about contractual agreement between two communities represented by different consensus ledgers.  To pretend otherwise will only hurt the cryptocurrency movement.</p>\n",
    "description": "Sidechains is more than one-way or two-way pegging, and beyond Bitcoin Maximalism.",
    "dateFriendly": "November 25, 2014"
  },
  {
    "title": "The Security of Cryptocurrency Protocols",
    "slug": "the-security-of-cryptocurrency-protocols",
    "date": 1416326400000,
    "body": "<p>Many solutions to the consensus problem for cryptocurrencies have been proposed.  Since the innovation of Bitcoin’s proof-of-work based consensus algorithm–where miners compete in an energy intensive game to determine the order of transactions–several proof-of-stake algorithms have been proposed to make consensus faster while removing the reliance on energy expenditure.  The common objective of these protocols is to maintain a live decentralized transaction ledger while defending against double-spend attacks from malicious Byzantine actors deviating from the protocol.  Considering the financial nature of these protocols, we should strive to support a protocol that has well defined and robust security guarantees.</p>\n<p>The security analysis of cryptocurrency protocols is complicated by many factors.   One such complicating factor is the rational self-interested nature of participants.  The ideal protocol is an incentive aligned Nash equilibrium such that deviating from the protocol does not result in a net gain [<a href=\"http://fc14.ifca.ai/papers/fc14_submission_82.pdf\">1</a>, <a href=\"https://www.cs.princeton.edu/~kroll/papers/weis13_bitcoin.pdf\">2</a>].  This is a topic worthy of its own post, but won’t be discussed further here.</p>\n<p>Another complicating factor is whether the power to achieve or disrupt consensus is extrinsic in origin (e.g. access to the production of mining equipment or cheap access to electricity) or intrinsic in origin (e.g. the “stake” of validators in proof-of-stake protocols) and whether the disruption of consensus–especially via a successful double-spend attack–is associated with a commensurate penalty.  The problem with extrinsic factors of security is that they are not easily quantifiable for analysis.  For example, the depreciation costs of Bitcoin mining hardware in the event of a successful double-spend attack may not be significant compared to the running costs of electricity in mining.  On the other hand existing proof-of-stake protocols do not have a well defined intrinsic penalty for instigators of a double-spend attack.  This is commonly called, ironically, the “nothing at stake” problem.  Newer protocols like the BitShares delegated-proof-of-stake protocol attempt to address this problem by placing the role of ranked-delegate at stake, but security is dependant on the extrinsic ability of stakeholders to accurately predict the future performance of delegates.</p>\n<p>What is needed is a radical simplification.  Security analysis is much simpler for an intrinsically secure cryptocurrency protocol when it can be proved that launching a double-spend attack necessarily results in a very high intrinsic penalty compared to the possible intrinsic gains.  Then, the protocol may be considered resistant to double-spent attacks assuming no further extrinsic complications.</p>\n<p>For example, consider a protocol that requires stakeholders to first post a surety bond before becoming a validator to participate in the consensus process.  To get the bonded coins back, the validator must first submit an unbonding transaction and wait a fixed, relatively long duration of time.  The validator’s only duty until the unbonding period is over is to participate in the protocol while taking care not to sign two blocks at the same height: the only way to fork the block-chain.  The validator that signs duplicitously loses its bonded coins as evidence of duplicity is entered onto the block-chain.  This protocol might adapt an existing Byzantine consensus algorithm from academic research (e.g. one proposed by Dwork, et al. [<a href=\"http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf\">3</a>]) to create a quorum of validators that agree on and sign the next block.  For a partially synchronous network (such as the Internet) at least two thirds of voting power is needed to agree on the next block, and up to one third of Byzantine voting power can be tolerated.  A double-spend attack implies a fork in the block-chain, which by simple arithmetic requires at least one third of voting power to have signed duplicitously.</p>\n<p>The above proposed protocol is secured by completely intrinsic means; it does not require a massive expenditure of energy to secure.  The total intrinsic penalty for successfully launching a double-spend attack (which is at least one third of all bonded coins as mentioned previously) can be adjusted by judiciously setting the incentives given to validators by way of fees or inflationary rewards.  The block-chain does not fork at all except in extraordinary circumstances, making it ideally suited for side-chain extensions.  It is to the my best knowledge the only completely decentralized cryptocurrency protocol that could be proven to be intrinsically incentive aligned.  Perhaps it is time to consider this kind of algorithm.</p>\n<h2>Links</h2>\n<ol>\n<li>Eyal and Sirer.  The Majority is Not Enough. 2014, <a href=\"http://fc14.ifca.ai/papers/fc14_submission_82.pdf\">http://fc14.ifca.ai/papers/fc14_submission_82.pdf</a></li>\n<li>Kroll et al.  The Economics of Bitcoin Mining, or Bitcoin in the Presence of Adversaries. 2013, <a href=\"https://www.cs.princeton.edu/~kroll/papers/weis13_bitcoin.pdf\">https://www.cs.princeton.edu/~kroll/papers/weis13_bitcoin.pdf</a></li>\n<li>Dwork, Lynch, and Stockmeyer.  Consensus in the Presence of Partial Synchrony. 1988, <a href=\"http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf\">http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf</a></li>\n</ol>\n",
    "description": "Security analysis of cryptocurrency protocols is complicated by incentive-alignment and extrinsic factors.  A look at more robust security guarantees",
    "dateFriendly": "November 19, 2014"
  }
]